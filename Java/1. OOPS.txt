
âœ… Java OOPs Interview Q&A

ğŸ”¹ 4 Pillars of OOPs

ğŸ”¹  Encapsulation â†’ Wrapping data & methods into a class.

class Account {
    private double balance;
    public void deposit(double amt) { balance += amt; }
    public double getBalance() { return balance; }
}


ğŸ”¹ inheritance â†’ Reusing parent class features.

class Animal { void sound(){ } }
class Dog extends Animal { void sound(){ System.out.println("Bark"); } }


ğŸ”¹  Polymorphism â†’ One method, many forms (overloading, overriding).

class Calculator {
    int add(int a, int b){ return a+b; } // Overload 1
    double add(double a, double b){ return a+b; } // Overload 2
}


ğŸ”¹  Abstraction â†’ Hiding implementation.

abstract class Shape { abstract void draw(); }
class Circle extends Shape { void draw(){ System.out.println("Circle"); } }


ğŸ”¹ Class vs Object

Class: Blueprint/template (e.g., Car class).
Object: Instance of class (e.g., new Car()).

ğŸ”¹ Encapsulation vs Abstraction

Encapsulation â†’ Implementation technique (data hiding with private + getters/setters).
Abstraction â†’ Design principle (show what, hide how via abstract classes/interfaces).


ğŸ”¹ Method Overloading vs Overriding

Overloading â†’ Same method name, diff parameters, same/different return type, compile-time.
Overriding â†’ Same method signature in child class, return type can be covariant, runtime.


ğŸ”¹ Compile-time vs Runtime Polymorphism

Compile-time (static) â†’ Method overloading.
Runtime (dynamic) â†’ Method overriding (dynamic method dispatch).

ğŸ”¹ Can we overload main()?

âœ… Yes, multiple main() methods allowed with diff params,
but JVM only calls public static void main(String[] args).


ğŸ”¹ Can we override static method?

âŒ No.
Static methods belong to class, not object.
If re-declared, itâ€™s method hiding, not overriding.


ğŸ”¹ this vs super

this â†’ Refers to current object.
super â†’ Refers to parent class (constructor, variables, methods).


ğŸ”¹ Constructor Overloading & Overriding


Overloading â†’ âœ… Yes (diff parameters).
Overriding â†’ âŒ No (constructors are not inherited).


ğŸ”¹ Object reference vs Object

Object reference â†’ Variable that points to object in heap.
Object itself â†’ Actual memory in heap.


âœ… Encapsulation
Definition â†’ Binding data + methods inside class, restricting direct access.
Helps achieve data hiding â†’ By making fields private.
Private + Getters/Setters â†’ Allow controlled access.
Without setters/getters? â†’ Yes (can have immutable objects with only getters).


âœ… Inheritance
Definition â†’ Mechanism to acquire properties from parent (extends).

Types:

Single âœ…
Multilevel âœ…
Hierarchical âœ…
Multiple âŒ (but supported via interfaces).
extends vs implements â†’ extends â†’ class inheritance, implements â†’ interface implementation.

IS-A vs HAS-A â†’

IS-A â†’ Inheritance (Dog IS-A Animal).
HAS-A â†’ Composition (Car HAS-A Engine).
Composition vs Inheritance â†’ Composition is preferred (loose coupling).

âœ… Polymorphism

Definition â†’ One entity behaving differently in different contexts.
Overloading rules: Change parameter list, canâ€™t only change return type.
Overriding rules: Same signature, same/diff covariant return type, not private/final/static.

Covariant return type â†’ Child class return allowed in overriding.
Dynamic method dispatch â†’ At runtime, JVM calls overridden method via object type.
Override private/final? âŒ No.
Overload only by return type? âŒ No, must differ in parameters.

âœ… Abstraction

Definition â†’ Hiding implementation, showing only functionality.

Abstract class vs Interface â†’

Abstract: partial abstraction, fields allowed, constructors allowed.
Interface: 100% abstraction (till Java 7), supports multiple inheritance.
Abstract class constructor? âœ… Yes, used for initialization in subclasses.
Interface default/static methods? âœ… Yes (Java 8+).
Marker interface â†’ Empty interface (Serializable) â†’ gives metadata to JVM.
Functional interface â†’ Exactly 1 abstract method (Runnable, Callable, Predicate).
Can we create object of abstract class? âŒ No, only via subclass.


ğŸ”¹ Interview Tip
If asked â€œWhen to use?â€ ğŸ‘‰
Abstract class â†’ When classes are closely related, share state + some common code.
Interface â†’ When unrelated classes should follow the same contract (e.g., Comparable, Runnable).


âœ… Object Class & Core Methods

Object class role â†’ Root parent of all classes.
== vs equals() â†’

== â†’ reference comparison.
equals() â†’ content comparison (override required).

equals() & hashCode() â†’ Must override both for HashMap/HashSet.
toString() â†’ Returns string representation of object.

finalize() vs finally â†’

finalize(): Called by GC before destroying object.
finally: Always executes after try-catch.

clone() â†’ Creates copy.
Shallow copy â†’ Copies object, not referenced objects.
Deep copy â†’ Copies object + referenced objects.



âœ… Keywords & Advanced OOPs

static variable â†’ Shared across all objects.
static method â†’ Belongs to class, canâ€™t access instance vars directly.
static block â†’ Runs once when class loads.
final + abstract class? âŒ No (contradiction: abstract â†’ extendable, final â†’ not extendable).
Blank final variable â†’ Final but not initialized at declaration, must be in constructor.

Interface extending multiple interfaces? âœ… Yes.

Diamond problem â†’ Multiple inheritance ambiguity. Solved in Java via interfaces with explicit override.

Inner classes â†’

Member inner class
Static nested class
Local inner class
Anonymous inner class

Anonymous inner class â†’ Class without name, declared inline.
Runnable r = new Runnable();

{ 
public void run(){ System.out.println("Run"); 
} 
};



ğŸ”¹ equals() and hashCode() in Java

1. Purpose
equals() â†’ Compares object content for equality.
hashCode() â†’ Returns an int hash value for the object, used in hash-based collections (HashMap, HashSet).