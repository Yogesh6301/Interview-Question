1. Monolithic vs Microservices

Monolithic

Single unit: UI + business logic + DB all together.
One DB, one deployment.
Changes ‚Üí redeploy entire app.
Disadvantages: Hard to scale, tightly coupled, slower deployments, risk of total failure.

Microservices
Application split into independent, small services.
Each service owns its own DB.
Services communicate via APIs (REST/gRPC) or messaging (Kafka, RabbitMQ).
Tech flexibility (polyglot).
Independent dev, deployment, and scaling.
üëâ When to choose: Large, scalable, cloud-native systems.
üëâ When not: Small/simple apps (Monolith is better).


2. SOA vs Microservices

SOA: Big services + ESB + shared DB.
Microservices: Smaller, independent, no shared DB, lightweight APIs.
Analogy: SOA = shared hotel kitchen; Microservices = separate cloud kitchens.

3. Microservices Features

Independent deployability
Decentralized data
Black-box services (expose API only)
Polyglot (different languages/DBs per service)
Security via API Gateway (JWT, OAuth2, RBAC)
Observability: logging, metrics, tracing

4. Communication

Synchronous (immediate response)
REST APIs, gRPC, Feign client
‚úÖ Simple, real-time, strong consistency
‚ùå Tight coupling, risk of cascading failures

Asynchronous (event-driven)
Kafka, RabbitMQ, ActiveMQ
‚úÖ Scalable, decoupled, fault-tolerant
‚ùå Eventual consistency, harder debugging


Patterns:

PTP (Queue) ‚Üí one consumer only
Pub/Sub (Topic) ‚Üí multiple consumers
Event-driven ‚Üí services react to published events

5. Scaling

Horizontal Scaling ‚Üí add service instances
Vertical Scaling ‚Üí add CPU/RAM
Auto-scaling ‚Üí Kubernetes HPA, AWS Auto Scaling
Load Balancing ‚Üí NGINX, Spring Cloud LB
Caching ‚Üí Redis, Memcached
DB Scaling ‚Üí Replication, Sharding, Read replicas
Async Processing ‚Üí Background jobs with Kafka/RabbitMQ

6. Data Consistency

Strong Consistency ‚Üí via sync calls (but tightly coupled)
Eventual Consistency ‚Üí via async events (preferred in MS)
Saga Pattern ‚Üí distributed transaction mgmt
Choreography: services react to each other‚Äôs events (no central control)
Orchestration: central orchestrator manages the flow
CQRS ‚Üí separate write/read models
Event Sourcing ‚Üí store state as sequence of events
Idempotency ‚Üí safe retries (same result no matter how many times run)

7. Saga vs 2PC

2PC (Two Phase Commit): Strong consistency, blocking, not fault-tolerant, bad for distributed systems.
Saga: Eventual consistency, non-blocking, scalable, uses compensating transactions.
üëâ Preferred in Microservices = Saga

8. Resilience & Fault Tolerance 

Circuit Breaker: Stop calls to failing service (Resilience4j, Hystrix).
Retries + Timeouts: avoid hanging requests.
Bulkhead: isolate failures by resource partitioning.
Resilience = ability to fail gracefully and recover.

9. API Gateway

Entry point for clients ‚Üí routes to services.
Features: load balancing, rate limiting, security (JWT/OAuth2), logging.
Tools: Spring Cloud Gateway, Kong, Zuul.

10. Security

Authentication: JWT, OAuth2, Keycloak.
Authorization: RBAC.
mTLS: Service-to-service secure comms.
API Gateway usually manages this.

11. Observability

Logging: ELK, Loki
Monitoring: Prometheus, Grafana
Tracing: Zipkin, Jaeger, Tempo
Needed for debugging distributed services.

12. Testing

Unit Test: single class/method.
Integration Test: service + DB/external APIs.
Contract Test: ensures API compatibility (Pact).
E2E Test: across multiple services.

13. Deployment & DevOps

Service Discovery: Eureka, Consul
Config Server: Spring Cloud Config
CI/CD: Jenkins, GitHub Actions, GitLab CI
Container Orchestration: Kubernetes, Docker Swarm
Deployment strategies:
Blue/Green ‚Üí switch traffic instantly
Canary ‚Üí gradual rollout
Chaos Testing: simulate random failures (Chaos Monkey).

14. When to use Monolith vs Microservices

Monolith: Small/simple apps, small team, faster dev, fewer resources.
Microservices: Large, scalable, frequent deployments, big teams, cloud-native.

15. Example MS Design

E-commerce app:
Product Service
Order Service
Payment Service
Inventory Service
Notification Service
Sync (REST) ‚Üí Order ‚Üí Payment
Async (Kafka) ‚Üí Order ‚Üí Notification, Analytics

‚úÖ Key Interview Tips

Always explain with real-life examples (E-commerce, Food Delivery, Banking).
Show awareness of trade-offs (Sync = simple but tightly coupled, Async = scalable but eventual consistency).
Highlight patterns: Saga, Circuit Breaker, CQRS, Event Sourcing.
Stress resilience, observability, and security in answers.
If asked ‚ÄúWhat did you use?‚Äù ‚Üí Answer:
Sync (REST) for critical transactions (Order ‚Üí Payment).
Async (Kafka) for notifications, analytics, background tasks.