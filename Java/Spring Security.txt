Spring Security Interview Questions & Answers

1. What is Spring Security and why do we use it?
Spring Security is a powerful authentication and authorization framework for securing Java applications.
It provides:
Authentication (verifying user identity).
Authorization (deciding what resources a user can access).
Protection against attacks like CSRF, session fixation, clickjacking.

2. How does Spring Security work internally?
Every request goes through the Spring Security Filter Chain (delegating filters).
Common filters: UsernamePasswordAuthenticationFilter, ExceptionTranslationFilter, FilterSecurityInterceptor.
AuthenticationManager authenticates the request (using UserDetailsService + PasswordEncoder).
If authenticated → stored in SecurityContextHolder.
Authorization checks roles/authorities before accessing resources.

3. What is the difference between Authentication and Authorization?
Authentication: Who you are (identity verification). Example: login with username/password.
Authorization: What you can access (permission check). Example: only ADMIN can delete users.

4. How do you configure security in Spring Boot 3.x (Spring Security 6)?
From Spring Security 6, WebSecurityConfigurerAdapter is deprecated. We use SecurityFilterChain bean.

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .requestMatchers("/user/**").hasAnyRole("USER","ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin()
            .and()
            .httpBasic();
        return http.build();
    }
}

5. What is UserDetailsService in Spring Security?
UserDetailsService is a core interface that loads user-specific data.
We implement it to fetch user details from DB (username, password, roles).

Example:
@Service
public class MyUserDetailsService implements UserDetailsService {
    @Autowired private UserRepository repo;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = repo.findByUsername(username)
                        .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        return new org.springframework.security.core.userdetails.User(
            user.getUsername(), user.getPassword(), getAuthorities(user));
    }
}

6. How do you secure REST APIs with JWT in Spring Boot?
User logs in with username/password.
Backend validates and generates a JWT token.
JWT is returned to client, stored in frontend (localStorage/cookie).
Each request carries Authorization: Bearer <token>.
A custom filter validates the token before processing the request.

7. What is CSRF and how do you handle it in Spring Security?
CSRF (Cross Site Request Forgery): Attacker tricks a logged-in user into performing unwanted actions.
Spring Security enables CSRF protection by default.
For stateless REST APIs using JWT, we usually disable CSRF because we don’t use cookies-based sessions.

8. How do you implement Role-Based Access Control (RBAC)?
Using @PreAuthorize, @Secured, or method-level security.

Example:

@PreAuthorize("hasRole('ADMIN')")
@GetMapping("/admin")
public String adminEndpoint() {
    return "Admin access only";
}

9. What is the difference between hasRole() and hasAuthority()?
hasRole("ADMIN") → Prefixes role with ROLE_ (expects ROLE_ADMIN).
hasAuthority("ADMIN") → Matches exact authority string.

10. How do you secure Microservices in Spring Boot?
Use OAuth2 + JWT tokens for service-to-service communication.
Implement API Gateway security (validate tokens at gateway).
Use Spring Cloud Security or integrate with Keycloak / Okta.