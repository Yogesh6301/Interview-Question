1. Basics of Threading

Q1. What is a thread in Java? How is it different from a process?
üëâ A thread is the smallest unit of execution within a process. Threads in the same process share memory (heap), but each has its own call stack and program counter. A process is heavier, has its own memory space, and inter-process communication is slower compared to threads.

Q2. What are the advantages and disadvantages of multithreading?

‚úÖ Advantages: Better CPU utilization, responsiveness, faster execution, resource sharing.
‚ùå Disadvantages: Complexity (race conditions, deadlocks), context switching overhead, resource contention.


Q3. How can you create a thread in Java? Which way is preferred?
Extending Thread class.
Implementing Runnable interface (preferred ‚Üí allows multiple inheritance).
Using Callable + Future (if result/exception handling is needed).
In real projects ‚Üí use ExecutorService (thread pools).

Q4. Difference between start() and run()?
start() ‚Üí Creates a new thread and executes run() in parallel.
run() ‚Üí Normal method call, runs in the current thread.


Q5. When would you use Callable instead of Runnable?
When you need a task that returns a value or throws a checked exception. Callable works with Future to retrieve results.

3. Thread Lifecycle & Synchronization

Q6. What are the possible thread states in Java?
NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED.


Q7. What is a race condition? How do you avoid it?
üëâ Race condition occurs when multiple threads access and modify shared data concurrently, leading to inconsistent results.
‚úÖ Avoid it using synchronization (synchronized, Locks, Atomic classes, or thread-safe collections).


Q8. What is the difference between synchronized method and synchronized block?
Synchronized method ‚Üí Locks the whole method.
Synchronized block ‚Üí Locks only the required critical section.
üëâ Block is preferred (more fine-grained, better performance).

Q9. Explain volatile keyword. When would you use it?
Ensures visibility of changes to variables across threads.
Does not ensure atomicity.
Use for flags (e.g., stopping a thread).


Q10. Difference between volatile and synchronized?
volatile ‚Üí Visibility only.
synchronized ‚Üí Visibility + atomicity + mutual exclusion.

4. Inter-thread Communication

Q11. Difference between sleep() and wait()?
sleep() ‚Üí Pauses thread for fixed time, does not release lock.
wait() ‚Üí Waits until notified, releases lock, must be inside synchronized block.


Q12. What are wait(), notify(), and notifyAll() used for?
They are used for inter-thread communication, typically in producer-consumer problems.

5. Thread Pools & Executors

Q13. Why should we use thread pools instead of creating new threads?
Avoids overhead of creating/destroying threads repeatedly.
Reuses threads ‚Üí better performance.
Controls number of concurrent threads.
Decouples task submission from thread management.

Q14. Difference between execute() and submit() in ExecutorService?
execute(Runnable) ‚Üí No return value.
submit(Runnable/Callable) ‚Üí Returns Future, allows result tracking.


Q15. Have you used ScheduledExecutorService?
üëâ Yes, it allows scheduling tasks after a delay or periodically. Example: scheduling cache refresh every 10 minutes.

6. Concurrency Utilities
Q16. Difference between synchronized and ReentrantLock?
synchronized ‚Üí Simpler, automatic release, no tryLock.
ReentrantLock ‚Üí More flexible (tryLock, lockInterruptibly, fairness, multiple conditions).

Q17. What is CountDownLatch and CyclicBarrier?
CountDownLatch ‚Üí Wait until a fixed number of tasks complete. (One-time use).
CyclicBarrier ‚Üí Wait until all threads reach a barrier point. (Reusable).

Q18. What is a Semaphore?
Used to control access to limited resources. Example: Limiting DB connections to 10.


Q19. What is BlockingQueue? Where is it used?

Thread-safe queue with blocking put() and take().
Commonly used in Producer-Consumer pattern.

Q20. What are Atomic classes in Java?

Classes like AtomicInteger, AtomicLong, AtomicBoolean.
Use hardware-level CAS operations for lock-free thread-safe updates.

7. Deadlocks & Advanced

Q21. What is a deadlock? How can you prevent it?
Deadlock = when two or more threads wait for each other‚Äôs resources indefinitely.
Prevention strategies:
Acquire locks in consistent order.
Use tryLock() with timeout.
Avoid nested locks.

Q22. Difference between deadlock, livelock, and starvation?

Deadlock ‚Üí Threads permanently blocked.
Livelock ‚Üí Threads keep retrying but no progress.
Starvation ‚Üí Thread never gets CPU due to unfair scheduling.


Q23. What is a ForkJoinPool?
Executor service for divide-and-conquer tasks (work-stealing algorithm).
Useful for parallel recursive tasks.


Q24. What is ThreadLocal? Where have you used it?
Provides thread-local variables (each thread has its own copy).
Example: Storing request context, DB connection, or SimpleDateFormat (since it‚Äôs not thread-safe).


Q25. How does ConcurrentHashMap differ from HashMap?
HashMap ‚Üí Not thread-safe.
ConcurrentHashMap ‚Üí Thread-safe with high concurrency (segment locking in Java 7, CAS in Java 8).