1. Singleton Pattern

Q1. What is the Singleton design pattern? Why is it used?
Ensures only one instance of a class exists in the JVM.
Provides a global point of access.
Used to manage shared resources (DB connections, logging, cache).

Q2. What are some common use cases of Singleton?
Logger (e.g., LogManager)
Configuration manager
Thread pool (Executors)
Database connection pool
Caches

Q3. How can we implement a Singleton in Java?
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}


Q4. What are the drawbacks of using a simple lazy initialization Singleton?
Not thread-safe (two threads can create two objects simultaneously).

Q5. How do you make a Singleton thread-safe?

Use synchronized method or block
Use Double Checked Locking (DCL)
Use Bill Pugh Singleton (static inner class)
Use Enum Singleton

Q6. Explain the difference between lazy initialization and eager initialization in Singleton.

Lazy: Object created only when needed → saves memory, but may face synchronization issues.
Eager: Object created at class loading → thread-safe, but may waste memory if unused.

Q7. What is double-checked locking in Singleton? Why do we use volatile?

public class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}


volatile prevents instruction reordering.
Ensures thread safety without performance overhead.

Q8. Explain the Bill Pugh Singleton (static inner class approach). Why is it recommended?

public class Singleton {
    private Singleton() {}
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}


Uses JVM’s class loading mechanism for thread safety.
Efficient & recommended.

Q9. What is the Enum Singleton and why is it considered the most robust?
public enum Singleton {
    INSTANCE;
}


Provides serialization and reflection safety.
Simple and thread-safe.

Q10. How do you prevent serialization and reflection attacks on Singleton?

Serialization: implement readResolve()
Reflection: throw exception in constructor if instance already exists.
Best: use Enum Singleton.

2. Factory Method Pattern

Q1. What is the Factory Method design pattern?
Defines an interface for creating objects but lets subclasses decide which class to instantiate.

Q2. How is Factory Method different from directly using the new keyword?
new → tightly coupled to concrete class.
Factory → decoupled, more flexible.

Q3. What is the benefit of using Factory Method?

Loose coupling
Easy extensibility (add new product without modifying client code).

Q4. Give a real-world example where Factory Pattern is useful.

Java Collections API: List list = List.of(...) or CollectionFactory.create("ArrayList").
JDBC: DriverManager.getConnection().

Q5. How does Factory Method improve loose coupling?

Client depends on abstract type (interface), not concrete implementation.

Q6. Can Factory Method return different types of objects? Give an example.
Yes.

class ShapeFactory {
    public static Shape getShape(String type) {
        if (type.equals("Circle")) return new Circle();
        if (type.equals("Square")) return new Square();
        return null;
    }
}


Q7. What’s the difference between Factory Method and Abstract Factory Pattern?

Factory Method: creates one product at a time.
Abstract Factory: creates families of related products.

3. Builder Pattern

Q1. What problem does the Builder pattern solve?

Solves issue of telescoping constructors (too many parameters).

Q2. Why do we prefer Builder over telescoping constructors?

Readable
Flexible (optional params easily handled)

Q3. How does the Builder pattern improve code readability?

Uses method chaining → looks like natural language.

Q4. Example of a real-world scenario where Builder is commonly used.

StringBuilder in Java
Lombok @Builder
HttpClient in modern Java

Q5. Can a Builder class be immutable? Why/Why not?

Builder is mutable while building.
Final object can be immutable.

Q6. How is the Builder pattern related to method chaining?

Each setter returns this → allows chaining.

Q7. Compare Builder vs Factory Method. When do you use which?

Factory: when object creation is simple.
Builder: when object has many optional params or is complex.

4. Observer Pattern

Q1. What is the Observer design pattern?

Defines a one-to-many dependency → when subject changes, observers get notified.

Q2. Real-world use case of Observer pattern?

UI event listeners
stock price alerts
Chat applications

Q3. Difference between Observer and Publisher-Subscriber?

Observer: tightly coupled (subject knows observers).
Pub-Sub: loosely coupled via event bus (like Kafka, JMS).

Q4. How does Observer help in event-driven programming?

Allows async updates when state changes.

Q5. Main components of the Observer pattern?

Subject (publisher)
Observer (subscriber)

Q6. Can one Subject have multiple Observers? How is this managed?
Yes. Subject maintains a list of observers.

Q7. Drawbacks of Observer pattern?

Memory leaks if observers not removed.
Too many updates may cause performance issues.

Q8. Why is java.util.Observer deprecated in Java, and what can be used instead?

Deprecated in Java 9 (too rigid, not functional).
Use java.beans.PropertyChangeListener or Flow API.

Q9. Example of Observer in Java libraries.
Swing ActionListener, MouseListener.
java.util.concurrent.Flow API (Reactive Streams).

Q10. How does the Observer pattern support the Open/Closed Principle in SOLID?
Subject is closed for modification but open for extension (new observers can subscribe).